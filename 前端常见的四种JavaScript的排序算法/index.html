<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    YuFy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="苏日俪格" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">苏日俪格</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/JS取经之路/">JS取经之路</a></li><li><a class="category-link" href="/categories/专业小tip/">专业小tip</a></li><li><a class="category-link" href="/categories/关于VueJs/">关于VueJs</a></li><li><a class="category-link" href="/categories/在项目中掘金/">在项目中掘金</a></li><li><a class="category-link" href="/categories/深入浅出ES6教程/">深入浅出ES6教程</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">Archive</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2019/03/">March 2019</a></li><li><a class="archive-link" href="/archives/2019/01/">January 2019</a></li><li><a class="archive-link" href="/archives/2018/08/">August 2018</a></li><li><a class="archive-link" href="/archives/2018/07/">July 2018</a></li><li><a class="archive-link" href="/archives/2018/06/">June 2018</a></li><li><a class="archive-link" href="/archives/2018/05/">May 2018</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="https://yufy1314.github.io/resume/" title="Resume">
		                Resume
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="Wesite">
		                Wesite
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="user" href="https://yufy1314.github.io/resume/" target="_blank" rel="noopener">
                            <i class="icon fa fa-user"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="github" href="https://github.com/yufy1314" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="book" href="https://www.jianshu.com/u/72f239ec5d03" target="_blank" rel="noopener">
                            <i class="icon fa fa-book"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/YuFy1314/YuFy1314.github.io/blob/master/images/blog-bg/javascript.png?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >JavaScript的事件执行机制---进阶必备</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;background: rgba(255,255,255,0.8);border-bottom-left-radius: 5px;border-bottom-right-radius: 5px;">
                <p>最近几天总结了一下前端常见的四种JavaScript的排序算法，拿出来给大家分享一下：<br>这四种排序算法依次是冒泡排序、选择排序、插入排序和快速排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h6 id="中心思想："><a href="#中心思想：" class="headerlink" title="中心思想："></a>中心思想：</h6><blockquote>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。</p>
</blockquote>
<h6 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h6><blockquote>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
</blockquote>
<h6 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let temp = 0;</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">        if (arr[i] &gt; arr[j]) &#123; // 相邻元素作比较,小的放前面大的放后面</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h6 id="中心思想：-1"><a href="#中心思想：-1" class="headerlink" title="中心思想："></a>中心思想：</h6><blockquote>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。</p>
</blockquote>
<h6 id="算法原理：-1"><a href="#算法原理：-1" class="headerlink" title="算法原理："></a>算法原理：</h6><blockquote>
<ol>
<li>比较相邻的元素。如果后面的元素比前面的元素小，则用一个变量key来记住该元素在数组中的索引。</li>
<li>接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量key来记住该元素在数组中的索引，循环结束之后可以找到最小的元素的索引。</li>
<li>然后判断如果这个最小元素的索引不是第一个元素的索引，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的值了。</li>
<li>重复以上步骤就可以接着找出整个数组中第二小的值等。</li>
</ol>
</blockquote>
<h6 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let temp = 0;</span><br><span class="line">let key = 0; // 用来记录最小值的索引</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    key = i; // 记录当前索引</span><br><span class="line">    for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">        if (arr[key] &gt; arr[j]) &#123; // 最小值和后一个值作比较</span><br><span class="line">            key = j; // 把新的最小值记录下来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[key];</span><br><span class="line">    arr[key] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h6 id="中心思想：-2"><a href="#中心思想：-2" class="headerlink" title="中心思想："></a>中心思想：</h6><blockquote>
<p>每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。</p>
</blockquote>
<h6 id="算法原理：-2"><a href="#算法原理：-2" class="headerlink" title="算法原理："></a>算法原理：</h6><blockquote>
<p>⒈ 从第一个元素开始，该元素可以认为已经被排序<br>⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>⒋ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⒌ 将新元素插入到下一位置中<br>⒍ 重复步骤2~5</p>
</blockquote>
<h6 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let iPrev = 0; // 前一个值的索引</span><br><span class="line">let iCurrent = 0; // 当前值</span><br><span class="line">for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    iPrev = i - 1;</span><br><span class="line">    iCurrent = arr[i];</span><br><span class="line">    while (iPrev &gt;= 0 &amp;&amp; iCurrent &lt; arr[iPrev]) &#123; // 当前值和前一个值作比较</span><br><span class="line">        arr[iPrev + 1] = arr[iPrev]; // 前一个值大即向后挪一位</span><br><span class="line">        iPrev--; // 继续和前一个值的前一个值作比较, 以此类推...</span><br><span class="line">    &#125;</span><br><span class="line">    arr[iPrev + 1] = iCurrent; // 当前值小即向前挪一位 ==&gt; 相当于和刚才比较的值互换位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h6 id="中心思想：-3"><a href="#中心思想：-3" class="headerlink" title="中心思想："></a>中心思想：</h6><blockquote>
<p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<h6 id="算法原理：-3"><a href="#算法原理：-3" class="headerlink" title="算法原理："></a>算法原理：</h6><blockquote>
<ol>
<li>定义两个变量iLeft、iRight，排序开始的时候：iLeft = 1，iRight = arr.length - 1，这两个小东西在代码中姑且叫它们为’左key’和’右key’，以此来确保数组左边的数都比‘关键数据’小,右边的数都比‘关键数据’大，这个‘关键数据’也就是下文中每次进入循环的新数组的第一项</li>
<li>接着用’右key’从数组的后面依次向前查找，直到找到一个小于等于‘关键数据’的为止。</li>
<li>接着用’左key’从数组的前面依次向后查找，直到找到一个大于等于‘关键数据’的为止。</li>
<li>步骤2和3会得到两个值，将他们的位置进行互换，再继续找。</li>
<li>重复步骤2~4，如果这一过程中’右key’和’左key’都落在了同一个值的身上时，直接将‘关键数据’和他们进行位置互换，再将当前数组以’关键数据’为基准切割成三个新的数组，递归新的数组到最后必然会有多个单项数组，再将这些单项数组拼接成新的数组也就是最终快排的结果。</li>
</ol>
</blockquote>
<h6 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (arr.length &lt; 2) &#123;  // 单项数组直接返回</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">// 下边的iLeft和iRight分别表示从数组的两端做检测</span><br><span class="line">let iLeft = 1; // 定义为: &apos;左key&apos;</span><br><span class="line">let iRight = arr.length - 1; // 定义为: &apos;右key&apos;</span><br><span class="line">while (iLeft &lt; iRight) &#123;</span><br><span class="line">    // arr[0] 每次进入循环的新的数组的第一个数作为&apos;关键数据&apos;,以此来确保左边的数都比它小,右边的数都比它大,分成三个新的数组</span><br><span class="line">    while (iLeft &lt; iRight &amp;&amp; arr[0] &lt;= arr[iRight]) &#123; // 确保&apos;左key&apos;小于&apos;右key&apos;的同时&apos;关键数据&apos;要小于等于&apos;右key&apos;的数据</span><br><span class="line">        iRight--; // &apos;右key&apos;开始向左检测</span><br><span class="line">    &#125;</span><br><span class="line">    while (iLeft &lt; iRight &amp;&amp; arr[0] &gt;= arr[iLeft]) &#123; // 确保&apos;左key&apos;小于&apos;右key&apos;的同时&apos;关键数据&apos;要大于等于&apos;左key&apos;的数据</span><br><span class="line">        iLeft++; // &apos;左key&apos;开始向右检测</span><br><span class="line">    &#125;</span><br><span class="line">    if (iLeft == iRight) &#123; // 两个key如果相等直接互换位置</span><br><span class="line">        let temp = null;</span><br><span class="line">        temp = arr[0];</span><br><span class="line">        arr[0] = arr[iRight];</span><br><span class="line">        arr[iRight] = temp;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    fnToTemp(arr, iLeft, iRight);</span><br><span class="line">&#125;</span><br><span class="line">// 接下来&apos;左key&apos;一旦大于等于&apos;右key&apos;, 即把当前数组以&apos;关键数据&apos;为基准切割成三个新的数组</span><br><span class="line">let newArrLeft = arr.slice(0, iLeft);</span><br><span class="line">let newArrCenter = arr.slice(iLeft, iRight + 1);</span><br><span class="line">let newArrRight = arr.slice(iRight + 1);</span><br><span class="line">// 递归每一个数组, 将每一个只包含一个数据的数组拼接成为新的数组也就是我们要的快速排序后的数组</span><br><span class="line">return fnSort(newArrLeft).concat(fnSort(newArrCenter)).concat(fnSort(newArrRight));</span><br></pre></td></tr></table></figure>
<p>以上四种排序算法总结就是这些，想要运行一下代码看看的朋友们可以<a href="https://jsfiddle.net/yufy_info/fnaz6x04/" target="_blank" rel="noopener">戳这里</a>，如果以上排序算法还有哪些原理或者代码不懂的可以在评论区指出，本人会第一时间安排Thanks♪(･ω･)ﾉ</p>
<p>希望大家阅读完本文可以有所收获，因为能力有限，掌握的知识也是不够全面，欢迎大家提出来一起分享！谢谢O(∩_∩)O~</p>
<p>欢迎访问<strong><a href="https://github.com/YuFy1314" target="_blank" rel="noopener">我的GitHub</a></strong>，喜欢的可以star，项目随意fork，支持转载但要下标注，同时恭候：<strong><a href="https://yufy1314.github.io/">个人博客</a></strong></p>
<p><img src="https://github.com/YuFy1314/YuFy1314.github.io/blob/master/images/blog-bg/javascript.png" alt=""></p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
